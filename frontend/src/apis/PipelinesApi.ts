// tslint:disable
/**
 * Nefryt LDS API
 * Database API for Nefryt LDS
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { HttpMethods, QueryConfig, ResponseBody, ResponseText } from 'redux-query';
import * as runtime from '../runtime';
import {
    Information,
    InformationFromJSON,
    InformationToJSON,
    Pipeline,
    PipelineFromJSON,
    PipelineToJSON,
    PipelineParam,
    PipelineParamFromJSON,
    PipelineParamToJSON,
} from '../models';

export interface CreatePipelineRequest {
    pipeline?: Pipeline;
}

export interface DeletePipelineByIdRequest {
    pipelineId: number;
}

export interface GetPipelineByIdRequest {
    pipelineId: number;
}

export interface ListPipelineParamsRequest {
    pipelineId: number;
}

export interface UpdatePipelineRequest {
    pipelineId: number;
    pipeline?: Pipeline;
}

export interface UpdatePipelineParamRequest {
    pipelineId: number;
    pipelineParamDefId: string;
    pipelineParam?: Array<PipelineParam>;
}


/**
 * Create a pipeline
 * Create pipeline
 */
function createPipelineRaw<T>(requestParameters: CreatePipelineRequest, requestConfig: runtime.TypedQueryConfig<T, Pipeline> = {}): QueryConfig<T> {
    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    headerParameters['Content-Type'] = 'application/json';


    const { meta = {} } = requestConfig;

    meta.authType = ['bearer'];
    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/pipeline`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'POST',
            headers: headerParameters,
        },
        body: queryParameters || PipelineToJSON(requestParameters.pipeline),
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(PipelineFromJSON(body), text);
    }

    return config;
}

/**
* Create a pipeline
* Create pipeline
*/
export function createPipeline<T>(requestParameters: CreatePipelineRequest, requestConfig?: runtime.TypedQueryConfig<T, Pipeline>): QueryConfig<T> {
    return createPipelineRaw(requestParameters, requestConfig);
}

/**
 * Deletes specific pipeline
 * Deletes pipeline
 */
function deletePipelineByIdRaw<T>(requestParameters: DeletePipelineByIdRequest, requestConfig: runtime.TypedQueryConfig<T, Information> = {}): QueryConfig<T> {
    if (requestParameters.pipelineId === null || requestParameters.pipelineId === undefined) {
        throw new runtime.RequiredError('pipelineId','Required parameter requestParameters.pipelineId was null or undefined when calling deletePipelineById.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};


    const { meta = {} } = requestConfig;

    meta.authType = ['bearer'];
    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/pipeline/{pipelineId}`.replace(`{${"pipelineId"}}`, encodeURIComponent(String(requestParameters.pipelineId))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'DELETE',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(InformationFromJSON(body), text);
    }

    return config;
}

/**
* Deletes specific pipeline
* Deletes pipeline
*/
export function deletePipelineById<T>(requestParameters: DeletePipelineByIdRequest, requestConfig?: runtime.TypedQueryConfig<T, Information>): QueryConfig<T> {
    return deletePipelineByIdRaw(requestParameters, requestConfig);
}

/**
 * Info for specific pipeline
 * Gets pipeline details
 */
function getPipelineByIdRaw<T>(requestParameters: GetPipelineByIdRequest, requestConfig: runtime.TypedQueryConfig<T, Pipeline> = {}): QueryConfig<T> {
    if (requestParameters.pipelineId === null || requestParameters.pipelineId === undefined) {
        throw new runtime.RequiredError('pipelineId','Required parameter requestParameters.pipelineId was null or undefined when calling getPipelineById.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};


    const { meta = {} } = requestConfig;

    meta.authType = ['bearer'];
    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/pipeline/{pipelineId}`.replace(`{${"pipelineId"}}`, encodeURIComponent(String(requestParameters.pipelineId))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(PipelineFromJSON(body), text);
    }

    return config;
}

/**
* Info for specific pipeline
* Gets pipeline details
*/
export function getPipelineById<T>(requestParameters: GetPipelineByIdRequest, requestConfig?: runtime.TypedQueryConfig<T, Pipeline>): QueryConfig<T> {
    return getPipelineByIdRaw(requestParameters, requestConfig);
}

/**
 * List all  pipeline params
 * List pipelnie pipeline params
 */
function listPipelineParamsRaw<T>(requestParameters: ListPipelineParamsRequest, requestConfig: runtime.TypedQueryConfig<T, Array<PipelineParam>> = {}): QueryConfig<T> {
    if (requestParameters.pipelineId === null || requestParameters.pipelineId === undefined) {
        throw new runtime.RequiredError('pipelineId','Required parameter requestParameters.pipelineId was null or undefined when calling listPipelineParams.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};


    const { meta = {} } = requestConfig;

    meta.authType = ['bearer'];
    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/pipeline/{pipelineId}/param`.replace(`{${"pipelineId"}}`, encodeURIComponent(String(requestParameters.pipelineId))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(body.map(PipelineParamFromJSON), text);
    }

    return config;
}

/**
* List all  pipeline params
* List pipelnie pipeline params
*/
export function listPipelineParams<T>(requestParameters: ListPipelineParamsRequest, requestConfig?: runtime.TypedQueryConfig<T, Array<PipelineParam>>): QueryConfig<T> {
    return listPipelineParamsRaw(requestParameters, requestConfig);
}

/**
 * List all pipelines
 * List pipelines
 */
function listPipelinesRaw<T>( requestConfig: runtime.TypedQueryConfig<T, Array<Pipeline>> = {}): QueryConfig<T> {
    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};


    const { meta = {} } = requestConfig;

    meta.authType = ['bearer'];
    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/pipeline`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(body.map(PipelineFromJSON), text);
    }

    return config;
}

/**
* List all pipelines
* List pipelines
*/
export function listPipelines<T>( requestConfig?: runtime.TypedQueryConfig<T, Array<Pipeline>>): QueryConfig<T> {
    return listPipelinesRaw( requestConfig);
}

/**
 * Updates pipeline
 * Updates pipeline
 */
function updatePipelineRaw<T>(requestParameters: UpdatePipelineRequest, requestConfig: runtime.TypedQueryConfig<T, Pipeline> = {}): QueryConfig<T> {
    if (requestParameters.pipelineId === null || requestParameters.pipelineId === undefined) {
        throw new runtime.RequiredError('pipelineId','Required parameter requestParameters.pipelineId was null or undefined when calling updatePipeline.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    headerParameters['Content-Type'] = 'application/json';


    const { meta = {} } = requestConfig;

    meta.authType = ['bearer'];
    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/pipeline/{pipelineId}`.replace(`{${"pipelineId"}}`, encodeURIComponent(String(requestParameters.pipelineId))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'PUT',
            headers: headerParameters,
        },
        body: queryParameters || PipelineToJSON(requestParameters.pipeline),
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(PipelineFromJSON(body), text);
    }

    return config;
}

/**
* Updates pipeline
* Updates pipeline
*/
export function updatePipeline<T>(requestParameters: UpdatePipelineRequest, requestConfig?: runtime.TypedQueryConfig<T, Pipeline>): QueryConfig<T> {
    return updatePipelineRaw(requestParameters, requestConfig);
}

/**
 * Put  pipeline params
 * Put pipelnie pipeline params
 */
function updatePipelineParamRaw<T>(requestParameters: UpdatePipelineParamRequest, requestConfig: runtime.TypedQueryConfig<T, Information> = {}): QueryConfig<T> {
    if (requestParameters.pipelineId === null || requestParameters.pipelineId === undefined) {
        throw new runtime.RequiredError('pipelineId','Required parameter requestParameters.pipelineId was null or undefined when calling updatePipelineParam.');
    }

    if (requestParameters.pipelineParamDefId === null || requestParameters.pipelineParamDefId === undefined) {
        throw new runtime.RequiredError('pipelineParamDefId','Required parameter requestParameters.pipelineParamDefId was null or undefined when calling updatePipelineParam.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    headerParameters['Content-Type'] = 'application/json';


    const { meta = {} } = requestConfig;

    meta.authType = ['bearer'];
    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/pipeline/{pipelineId}/param/{methodParamDefId}`.replace(`{${"pipelineId"}}`, encodeURIComponent(String(requestParameters.pipelineId))).replace(`{${"pipelineParamDefId"}}`, encodeURIComponent(String(requestParameters.pipelineParamDefId))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'PUT',
            headers: headerParameters,
        },
        body: queryParameters || requestParameters.pipelineParam?.map(PipelineParamToJSON),
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(InformationFromJSON(body), text);
    }

    return config;
}

/**
* Put  pipeline params
* Put pipelnie pipeline params
*/
export function updatePipelineParam<T>(requestParameters: UpdatePipelineParamRequest, requestConfig?: runtime.TypedQueryConfig<T, Information>): QueryConfig<T> {
    return updatePipelineParamRaw(requestParameters, requestConfig);
}

