// tslint:disable
/**
 * Nefryt LDS API
 * Database API for Nefryt LDS
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { HttpMethods, QueryConfig, ResponseBody, ResponseText } from 'redux-query';
import * as runtime from '../runtime';
import {
    EditorPipeline,
    EditorPipelineFromJSON,
    EditorPipelineToJSON,
    Information,
    InformationFromJSON,
    InformationToJSON,
} from '../models';

export interface EditorPipelineCreatePipelineRequest {
    editorPipeline?: Array<EditorPipeline>;
}

export interface EditorPipelineDeleteEditorPipelineByIdRequest {
    editorPipelineId: number;
}

export interface EditorPipelineDeleteEditorPipelinesRequest {
    editorPipeline?: Array<EditorPipeline>;
}

export interface EditorPipelineGetEditorPipelineByIdRequest {
    editorPipelineId: number;
}


/**
 * Create a editor pipelines
 * Create editor pipelines
 */
function editorPipelineCreatePipelineRaw<T>(requestParameters: EditorPipelineCreatePipelineRequest, requestConfig: runtime.TypedQueryConfig<T, Information> = {}): QueryConfig<T> {
    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    headerParameters['Content-Type'] = 'application/json';


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/editor/pipeline`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'POST',
            headers: headerParameters,
        },
        body: queryParameters || requestParameters.editorPipeline?.map(EditorPipelineToJSON),
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(InformationFromJSON(body), text);
    }

    return config;
}

/**
* Create a editor pipelines
* Create editor pipelines
*/
export function editorPipelineCreatePipeline<T>(requestParameters: EditorPipelineCreatePipelineRequest, requestConfig?: runtime.TypedQueryConfig<T, Information>): QueryConfig<T> {
    return editorPipelineCreatePipelineRaw(requestParameters, requestConfig);
}

/**
 * Delete specific editor pipeline
 * Delete editor pipeline
 */
function editorPipelineDeleteEditorPipelineByIdRaw<T>(requestParameters: EditorPipelineDeleteEditorPipelineByIdRequest, requestConfig: runtime.TypedQueryConfig<T, Information> = {}): QueryConfig<T> {
    if (requestParameters.editorPipelineId === null || requestParameters.editorPipelineId === undefined) {
        throw new runtime.RequiredError('editorPipelineId','Required parameter requestParameters.editorPipelineId was null or undefined when calling editorPipelineDeleteEditorPipelineById.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/editor/pipeline/{editorPipelineId}`.replace(`{${"editorPipelineId"}}`, encodeURIComponent(String(requestParameters.editorPipelineId))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'DELETE',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(InformationFromJSON(body), text);
    }

    return config;
}

/**
* Delete specific editor pipeline
* Delete editor pipeline
*/
export function editorPipelineDeleteEditorPipelineById<T>(requestParameters: EditorPipelineDeleteEditorPipelineByIdRequest, requestConfig?: runtime.TypedQueryConfig<T, Information>): QueryConfig<T> {
    return editorPipelineDeleteEditorPipelineByIdRaw(requestParameters, requestConfig);
}

/**
 * Delete editor pipelines
 * Detail editor pipelines
 */
function editorPipelineDeleteEditorPipelinesRaw<T>(requestParameters: EditorPipelineDeleteEditorPipelinesRequest, requestConfig: runtime.TypedQueryConfig<T, Information> = {}): QueryConfig<T> {
    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    headerParameters['Content-Type'] = 'application/json';


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/editor/pipeline`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'DELETE',
            headers: headerParameters,
        },
        body: queryParameters || requestParameters.editorPipeline?.map(EditorPipelineToJSON),
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(InformationFromJSON(body), text);
    }

    return config;
}

/**
* Delete editor pipelines
* Detail editor pipelines
*/
export function editorPipelineDeleteEditorPipelines<T>(requestParameters: EditorPipelineDeleteEditorPipelinesRequest, requestConfig?: runtime.TypedQueryConfig<T, Information>): QueryConfig<T> {
    return editorPipelineDeleteEditorPipelinesRaw(requestParameters, requestConfig);
}

/**
 * Info for specific editor pipeline
 * Detail editor pipeline
 */
function editorPipelineGetEditorPipelineByIdRaw<T>(requestParameters: EditorPipelineGetEditorPipelineByIdRequest, requestConfig: runtime.TypedQueryConfig<T, EditorPipeline> = {}): QueryConfig<T> {
    if (requestParameters.editorPipelineId === null || requestParameters.editorPipelineId === undefined) {
        throw new runtime.RequiredError('editorPipelineId','Required parameter requestParameters.editorPipelineId was null or undefined when calling editorPipelineGetEditorPipelineById.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/editor/pipeline/{editorPipelineId}`.replace(`{${"editorPipelineId"}}`, encodeURIComponent(String(requestParameters.editorPipelineId))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(EditorPipelineFromJSON(body), text);
    }

    return config;
}

/**
* Info for specific editor pipeline
* Detail editor pipeline
*/
export function editorPipelineGetEditorPipelineById<T>(requestParameters: EditorPipelineGetEditorPipelineByIdRequest, requestConfig?: runtime.TypedQueryConfig<T, EditorPipeline>): QueryConfig<T> {
    return editorPipelineGetEditorPipelineByIdRaw(requestParameters, requestConfig);
}

/**
 * List all editor pipelines
 * List editor pipelines
 */
function editorPipelineListPipelinesRaw<T>( requestConfig: runtime.TypedQueryConfig<T, Array<EditorPipeline>> = {}): QueryConfig<T> {
    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/editor/pipeline`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(body.map(EditorPipelineFromJSON), text);
    }

    return config;
}

/**
* List all editor pipelines
* List editor pipelines
*/
export function editorPipelineListPipelines<T>( requestConfig?: runtime.TypedQueryConfig<T, Array<EditorPipeline>>): QueryConfig<T> {
    return editorPipelineListPipelinesRaw( requestConfig);
}

