/* tslint:disable */
/* eslint-disable */
/**
 * Nefryt LDS API
 * Database API for Nefryt LDS
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface EditorNode
 */
export interface EditorNode {
    /**
     * none
     * @type {number}
     * @memberof EditorNode
     */
    'PosX': number;
    /**
     * none
     * @type {number}
     * @memberof EditorNode
     */
    'PosY': number;
}
/**
 * 
 * @export
 * @interface EditorPipeline
 */
export interface EditorPipeline {
    /**
     * none
     * @type {number}
     * @memberof EditorPipeline
     */
    'AreaWidth': number;
    /**
     * none
     * @type {number}
     * @memberof EditorPipeline
     */
    'AreaHeight': number;
    /**
     * none
     * @type {number}
     * @memberof EditorPipeline
     */
    'AreaWidthDivision': number;
    /**
     * none
     * @type {number}
     * @memberof EditorPipeline
     */
    'AreaHeightDivision': number;
}
/**
 * 
 * @export
 * @interface Event
 */
export interface Event {
    /**
     * none
     * @type {number}
     * @memberof Event
     */
    'ID'?: number;
    /**
     * none
     * @type {string}
     * @memberof Event
     */
    'EventDefID': string;
    /**
     * none
     * @type {number}
     * @memberof Event
     */
    'MethodID': number;
    /**
     * none
     * @type {string}
     * @memberof Event
     */
    'BeginDate': string;
    /**
     * none
     * @type {string}
     * @memberof Event
     */
    'AckDate'?: string;
    /**
     * none
     * @type {string}
     * @memberof Event
     */
    'EndDate'?: string;
    /**
     * none
     * @type {string}
     * @memberof Event
     */
    'Details'?: string;
    /**
     * none
     * @type {number}
     * @memberof Event
     */
    'Position'?: number;
    /**
     * none
     * @type {string}
     * @memberof Event
     */
    'Caption'?: string;
    /**
     * none
     * @type {string}
     * @memberof Event
     */
    'Verbosity'?: string;
    /**
     * none
     * @type {boolean}
     * @memberof Event
     */
    'Silient'?: boolean;
}
/**
 * 
 * @export
 * @interface EventDef
 */
export interface EventDef {
    /**
     * none
     * @type {string}
     * @memberof EventDef
     */
    'ID': string;
    /**
     * none
     * @type {string}
     * @memberof EventDef
     */
    'Verbosity'?: string;
    /**
     * none
     * @type {string}
     * @memberof EventDef
     */
    'Caption'?: string;
    /**
     * none
     * @type {boolean}
     * @memberof EventDef
     */
    'Silent'?: boolean;
    /**
     * none
     * @type {boolean}
     * @memberof EventDef
     */
    'Visible'?: boolean;
    /**
     * none
     * @type {boolean}
     * @memberof EventDef
     */
    'Enabled'?: boolean;
}
/**
 * 
 * @export
 * @interface Information
 */
export interface Information {
    /**
     * 
     * @type {number}
     * @memberof Information
     */
    'status': number;
    /**
     * 
     * @type {number}
     * @memberof Information
     */
    'affected': number;
    /**
     * 
     * @type {string}
     * @memberof Information
     */
    'message': string | null;
}
/**
 * 
 * @export
 * @interface Link
 */
export interface Link {
    /**
     * none
     * @type {number}
     * @memberof Link
     */
    'ID'?: number;
    /**
     * none
     * @type {number}
     * @memberof Link
     */
    'BeginNodeID'?: number;
    /**
     * none
     * @type {number}
     * @memberof Link
     */
    'EndNodeID'?: number;
    /**
     * none
     * @type {number}
     * @memberof Link
     */
    'Length'?: number;
}
/**
 * 
 * @export
 * @interface LoginPermissions
 */
export interface LoginPermissions {
    /**
     * 
     * @type {string}
     * @memberof LoginPermissions
     */
    'username'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof LoginPermissions
     */
    'success'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof LoginPermissions
     */
    'token': string;
    /**
     * 
     * @type {string}
     * @memberof LoginPermissions
     */
    'refreshToken': string;
    /**
     * 
     * @type {string}
     * @memberof LoginPermissions
     */
    'refreshTokenExpiration': string;
    /**
     * 
     * @type {Array<{ [key: string]: any; }>}
     * @memberof LoginPermissions
     */
    'permissions'?: Array<{ [key: string]: any; }>;
}
/**
 * 
 * @export
 * @interface Method
 */
export interface Method {
    /**
     * none
     * @type {number}
     * @memberof Method
     */
    'ID'?: number;
    /**
     * 
     * @type {number}
     * @memberof Method
     */
    'MethodDefID': number;
    /**
     * 
     * @type {number}
     * @memberof Method
     */
    'PipelineID': number;
    /**
     * 
     * @type {string}
     * @memberof Method
     */
    'Name'?: string;
}
/**
 * 
 * @export
 * @interface MethodDef
 */
export interface MethodDef {
    /**
     * none
     * @type {number}
     * @memberof MethodDef
     */
    'ID'?: number;
    /**
     * none
     * @type {string}
     * @memberof MethodDef
     */
    'Name'?: string;
}
/**
 * 
 * @export
 * @interface MethodParam
 */
export interface MethodParam {
    /**
     * none
     * @type {number}
     * @memberof MethodParam
     */
    'PipelineID': number;
    /**
     * none
     * @type {number}
     * @memberof MethodParam
     */
    'MethodID': number;
    /**
     * none
     * @type {number}
     * @memberof MethodParam
     */
    'MethodParamDefID'?: number;
    /**
     * none
     * @type {string}
     * @memberof MethodParam
     */
    'DataType'?: string;
    /**
     * none
     * @type {string}
     * @memberof MethodParam
     */
    'Name'?: string;
    /**
     * none
     * @type {string}
     * @memberof MethodParam
     */
    'Value'?: string;
}
/**
 * 
 * @export
 * @interface MethodParamDef
 */
export interface MethodParamDef {
    /**
     * none
     * @type {number}
     * @memberof MethodParamDef
     */
    'ID'?: number;
    /**
     * none
     * @type {number}
     * @memberof MethodParamDef
     */
    'MethodDefID'?: number;
    /**
     * none
     * @type {string}
     * @memberof MethodParamDef
     */
    'Name'?: string;
    /**
     * none
     * @type {string}
     * @memberof MethodParamDef
     */
    'DataType'?: string;
}
/**
 * 
 * @export
 * @interface ModelError
 */
export interface ModelError {
    /**
     * 
     * @type {number}
     * @memberof ModelError
     */
    'code': number;
    /**
     * 
     * @type {string}
     * @memberof ModelError
     */
    'message': string;
}
/**
 * 
 * @export
 * @interface Node
 */
export interface Node {
    /**
     * none
     * @type {number}
     * @memberof Node
     */
    'ID'?: number;
    /**
     * none
     * @type {string}
     * @memberof Node
     */
    'Type': string;
    /**
     * none
     * @type {number}
     * @memberof Node
     */
    'TrendID'?: number | null;
    /**
     * none
     * @type {string}
     * @memberof Node
     */
    'Name'?: string;
    /**
     * 
     * @type {EditorNode}
     * @memberof Node
     */
    'EditorParams'?: EditorNode;
}
/**
 * 
 * @export
 * @interface Pipeline
 */
export interface Pipeline {
    /**
     * none
     * @type {number}
     * @memberof Pipeline
     */
    'ID'?: number;
    /**
     * none
     * @type {string}
     * @memberof Pipeline
     */
    'Name'?: string;
    /**
     * none
     * @type {number}
     * @memberof Pipeline
     */
    'BeginPos'?: number;
    /**
     * 
     * @type {EditorPipeline}
     * @memberof Pipeline
     */
    'EditorParams'?: EditorPipeline;
}
/**
 * 
 * @export
 * @interface PipelineNode
 */
export interface PipelineNode {
    /**
     * none
     * @type {number}
     * @memberof PipelineNode
     */
    'ID'?: number;
    /**
     * none
     * @type {number}
     * @memberof PipelineNode
     */
    'NodeID': number;
    /**
     * none
     * @type {boolean}
     * @memberof PipelineNode
     */
    'First'?: boolean;
}
/**
 * 
 * @export
 * @interface PipelineParam
 */
export interface PipelineParam {
    /**
     * none
     * @type {number}
     * @memberof PipelineParam
     */
    'PipelineID': number;
    /**
     * none
     * @type {number}
     * @memberof PipelineParam
     */
    'PipelineParamDefID'?: number;
    /**
     * none
     * @type {string}
     * @memberof PipelineParam
     */
    'DataType'?: string;
    /**
     * none
     * @type {string}
     * @memberof PipelineParam
     */
    'Name'?: string;
    /**
     * none
     * @type {string}
     * @memberof PipelineParam
     */
    'Value'?: string;
}
/**
 * 
 * @export
 * @interface PipelineParamDef
 */
export interface PipelineParamDef {
    /**
     * none
     * @type {number}
     * @memberof PipelineParamDef
     */
    'ID'?: number;
    /**
     * none
     * @type {number}
     * @memberof PipelineParamDef
     */
    'PipelineDefID'?: number;
    /**
     * none
     * @type {string}
     * @memberof PipelineParamDef
     */
    'Name'?: string;
    /**
     * none
     * @type {string}
     * @memberof PipelineParamDef
     */
    'DataType'?: string;
}
/**
 * 
 * @export
 * @interface Trend
 */
export interface Trend {
    /**
     * none
     * @type {number}
     * @memberof Trend
     */
    'ID'?: number;
    /**
     * none
     * @type {string}
     * @memberof Trend
     */
    'Name'?: string;
    /**
     * none
     * @type {number}
     * @memberof Trend
     */
    'TrendGroupID'?: number;
    /**
     * none
     * @type {string}
     * @memberof Trend
     */
    'TrendDefID': string;
    /**
     * none
     * @type {number}
     * @memberof Trend
     */
    'NodeID'?: number;
    /**
     * none
     * @type {number}
     * @memberof Trend
     */
    'TimeExponent'?: number;
    /**
     * none
     * @type {string}
     * @memberof Trend
     */
    'Format'?: string;
    /**
     * none
     * @type {string}
     * @memberof Trend
     */
    'Unit'?: string;
    /**
     * 
     * @type {string}
     * @memberof Trend
     */
    'Color'?: string;
    /**
     * 
     * @type {string}
     * @memberof Trend
     */
    'Symbol'?: string;
    /**
     * none
     * @type {number}
     * @memberof Trend
     */
    'RawMin': number;
    /**
     * none
     * @type {number}
     * @memberof Trend
     */
    'RawMax': number;
    /**
     * none
     * @type {number}
     * @memberof Trend
     */
    'ScaledMin': number;
    /**
     * none
     * @type {number}
     * @memberof Trend
     */
    'ScaledMax': number;
}
/**
 * 
 * @export
 * @interface TrendData
 */
export interface TrendData {
    [key: string]: number | any;

    /**
     * 
     * @type {number}
     * @memberof TrendData
     */
    'Timestamp': number;
    /**
     * 
     * @type {number}
     * @memberof TrendData
     */
    'TimestampMs': number;
    /**
     * 
     * @type {Array<TrendDataDataInner>}
     * @memberof TrendData
     */
    'Data'?: Array<TrendDataDataInner>;
}
/**
 * @type TrendDataDataInner
 * @export
 */
export type TrendDataDataInner = null | TrendValue;

/**
 * 
 * @export
 * @interface TrendDef
 */
export interface TrendDef {
    /**
     * none
     * @type {string}
     * @memberof TrendDef
     */
    'ID': string;
    /**
     * none
     * @type {string}
     * @memberof TrendDef
     */
    'Name': string;
}
/**
 * 
 * @export
 * @interface TrendGroup
 */
export interface TrendGroup {
    /**
     * none
     * @type {number}
     * @memberof TrendGroup
     */
    'ID'?: number;
    /**
     * none
     * @type {string}
     * @memberof TrendGroup
     */
    'Name': string;
    /**
     * none
     * @type {boolean}
     * @memberof TrendGroup
     */
    'AnalisisOnly': boolean;
}
/**
 * 
 * @export
 * @interface TrendParam
 */
export interface TrendParam {
    /**
     * none
     * @type {number}
     * @memberof TrendParam
     */
    'TrendID': number;
    /**
     * 
     * @type {string}
     * @memberof TrendParam
     */
    'TrendParamDefID': string;
    /**
     * 
     * @type {string}
     * @memberof TrendParam
     */
    'Name'?: string;
    /**
     * 
     * @type {string}
     * @memberof TrendParam
     */
    'DataType'?: string;
    /**
     * 
     * @type {string}
     * @memberof TrendParam
     */
    'Value': string;
}
/**
 * 
 * @export
 * @interface TrendParamDef
 */
export interface TrendParamDef {
    /**
     * none
     * @type {number}
     * @memberof TrendParamDef
     */
    'ID'?: number;
    /**
     * none
     * @type {number}
     * @memberof TrendParamDef
     */
    'TrendDefID': number;
    /**
     * none
     * @type {string}
     * @memberof TrendParamDef
     */
    'Name'?: string;
    /**
     * none
     * @type {string}
     * @memberof TrendParamDef
     */
    'DataType'?: string;
}
/**
 * 
 * @export
 * @interface TrendValue
 */
export interface TrendValue {
    /**
     * 
     * @type {number}
     * @memberof TrendValue
     */
    'trendId': number;
    /**
     * 
     * @type {number}
     * @memberof TrendValue
     */
    'Value'?: number;
}
/**
 * 
 * @export
 * @interface Unauthorized
 */
export interface Unauthorized {
    /**
     * 
     * @type {string}
     * @memberof Unauthorized
     */
    'error': string;
    /**
     * 
     * @type {number}
     * @memberof Unauthorized
     */
    'status': number;
    /**
     * 
     * @type {string}
     * @memberof Unauthorized
     */
    'timestamp': string;
    /**
     * 
     * @type {string}
     * @memberof Unauthorized
     */
    'path': string;
    /**
     * 
     * @type {string}
     * @memberof Unauthorized
     */
    'message'?: string;
    /**
     * 
     * @type {string}
     * @memberof Unauthorized
     */
    'traceId'?: string;
}
/**
 * 
 * @export
 * @interface Unit
 */
export interface Unit {
    /**
     * 
     * @type {string}
     * @memberof Unit
     */
    'ID'?: string;
    /**
     * 
     * @type {string}
     * @memberof Unit
     */
    'Name'?: string;
    /**
     * 
     * @type {string}
     * @memberof Unit
     */
    'Symbol'?: string;
    /**
     * 
     * @type {string}
     * @memberof Unit
     */
    'BaseID'?: string;
    /**
     * 
     * @type {number}
     * @memberof Unit
     */
    'Multiplier'?: number;
}

/**
 * AuthApi - axios parameter creator
 * @export
 */
export const AuthApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Authentication Login
         * @param {string} username 
         * @param {string} password 
         * @param {string} [deviceId] 
         * @param {string} [deviceName] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authLogin: async (username: string, password: string, deviceId?: string, deviceName?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'username' is not null or undefined
            assertParamExists('authLogin', 'username', username)
            // verify required parameter 'password' is not null or undefined
            assertParamExists('authLogin', 'password', password)
            const localVarPath = `/auth/login`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new URLSearchParams();


            if (username !== undefined) { 
                localVarFormParams.set('username', username as any);
            }
    
            if (password !== undefined) { 
                localVarFormParams.set('password', password as any);
            }
    
            if (deviceId !== undefined) { 
                localVarFormParams.set('deviceId', deviceId as any);
            }
    
            if (deviceName !== undefined) { 
                localVarFormParams.set('deviceName', deviceName as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams.toString();

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Authentication token refresh
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authRefresh: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/refresh`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthApi - functional programming interface
 * @export
 */
export const AuthApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuthApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Authentication Login
         * @param {string} username 
         * @param {string} password 
         * @param {string} [deviceId] 
         * @param {string} [deviceName] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authLogin(username: string, password: string, deviceId?: string, deviceName?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LoginPermissions>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authLogin(username, password, deviceId, deviceName, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.authLogin']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Authentication token refresh
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authRefresh(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LoginPermissions>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authRefresh(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.authRefresh']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AuthApi - factory interface
 * @export
 */
export const AuthApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AuthApiFp(configuration)
    return {
        /**
         * 
         * @summary Authentication Login
         * @param {string} username 
         * @param {string} password 
         * @param {string} [deviceId] 
         * @param {string} [deviceName] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authLogin(username: string, password: string, deviceId?: string, deviceName?: string, options?: RawAxiosRequestConfig): AxiosPromise<LoginPermissions> {
            return localVarFp.authLogin(username, password, deviceId, deviceName, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Authentication token refresh
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authRefresh(options?: RawAxiosRequestConfig): AxiosPromise<LoginPermissions> {
            return localVarFp.authRefresh(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AuthApi - object-oriented interface
 * @export
 * @class AuthApi
 * @extends {BaseAPI}
 */
export class AuthApi extends BaseAPI {
    /**
     * 
     * @summary Authentication Login
     * @param {string} username 
     * @param {string} password 
     * @param {string} [deviceId] 
     * @param {string} [deviceName] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authLogin(username: string, password: string, deviceId?: string, deviceName?: string, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).authLogin(username, password, deviceId, deviceName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Authentication token refresh
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authRefresh(options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).authRefresh(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * EventsApi - axios parameter creator
 * @export
 */
export const EventsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Acknowledges an event
         * @summary Acknowledges ack
         * @param {number} eventId The id of the event to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ackEvent: async (eventId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventId' is not null or undefined
            assertParamExists('ackEvent', 'eventId', eventId)
            const localVarPath = `/event/{eventId}/ack`
                .replace(`{${"eventId"}}`, encodeURIComponent(String(eventId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create an event def
         * @summary Create event def
         * @param {EventDef} [eventDef] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEventDef: async (eventDef?: EventDef, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/event_def`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(eventDef, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete specific event def
         * @summary Deletes event def
         * @param {string} eventDefId The id of the event def to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEventDefById: async (eventDefId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventDefId' is not null or undefined
            assertParamExists('deleteEventDefById', 'eventDefId', eventDefId)
            const localVarPath = `/event_def/{eventDefId}`
                .replace(`{${"eventDefId"}}`, encodeURIComponent(String(eventDefId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Info for specific event
         * @summary Gets detailed event
         * @param {number} eventId The id of the event to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventById: async (eventId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventId' is not null or undefined
            assertParamExists('getEventById', 'eventId', eventId)
            const localVarPath = `/event/{eventId}`
                .replace(`{${"eventId"}}`, encodeURIComponent(String(eventId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Info for specific event def
         * @summary Gets event def details
         * @param {string} eventDefId The id of the event def to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventDefById: async (eventDefId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventDefId' is not null or undefined
            assertParamExists('getEventDefById', 'eventDefId', eventDefId)
            const localVarPath = `/event_def/{eventDefId}`
                .replace(`{${"eventDefId"}}`, encodeURIComponent(String(eventDefId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all event defs
         * @summary List event defs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listEventDefs: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/event_def`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all events
         * @summary List events
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listEvents: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/event`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update event def
         * @summary Updates event def
         * @param {string} eventDefId The id of the event def to retrieve
         * @param {EventDef} [eventDef] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEventDef: async (eventDefId: string, eventDef?: EventDef, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventDefId' is not null or undefined
            assertParamExists('updateEventDef', 'eventDefId', eventDefId)
            const localVarPath = `/event_def/{eventDefId}`
                .replace(`{${"eventDefId"}}`, encodeURIComponent(String(eventDefId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(eventDef, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EventsApi - functional programming interface
 * @export
 */
export const EventsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = EventsApiAxiosParamCreator(configuration)
    return {
        /**
         * Acknowledges an event
         * @summary Acknowledges ack
         * @param {number} eventId The id of the event to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ackEvent(eventId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Information>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ackEvent(eventId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EventsApi.ackEvent']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create an event def
         * @summary Create event def
         * @param {EventDef} [eventDef] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createEventDef(eventDef?: EventDef, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EventDef>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createEventDef(eventDef, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EventsApi.createEventDef']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete specific event def
         * @summary Deletes event def
         * @param {string} eventDefId The id of the event def to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteEventDefById(eventDefId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteEventDefById(eventDefId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EventsApi.deleteEventDefById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Info for specific event
         * @summary Gets detailed event
         * @param {number} eventId The id of the event to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEventById(eventId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Event>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEventById(eventId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EventsApi.getEventById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Info for specific event def
         * @summary Gets event def details
         * @param {string} eventDefId The id of the event def to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEventDefById(eventDefId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EventDef>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEventDefById(eventDefId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EventsApi.getEventDefById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List all event defs
         * @summary List event defs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listEventDefs(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<EventDef>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listEventDefs(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EventsApi.listEventDefs']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List all events
         * @summary List events
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listEvents(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Event>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listEvents(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EventsApi.listEvents']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update event def
         * @summary Updates event def
         * @param {string} eventDefId The id of the event def to retrieve
         * @param {EventDef} [eventDef] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateEventDef(eventDefId: string, eventDef?: EventDef, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EventDef>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateEventDef(eventDefId, eventDef, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EventsApi.updateEventDef']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * EventsApi - factory interface
 * @export
 */
export const EventsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = EventsApiFp(configuration)
    return {
        /**
         * Acknowledges an event
         * @summary Acknowledges ack
         * @param {number} eventId The id of the event to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ackEvent(eventId: number, options?: RawAxiosRequestConfig): AxiosPromise<Information> {
            return localVarFp.ackEvent(eventId, options).then((request) => request(axios, basePath));
        },
        /**
         * Create an event def
         * @summary Create event def
         * @param {EventDef} [eventDef] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEventDef(eventDef?: EventDef, options?: RawAxiosRequestConfig): AxiosPromise<EventDef> {
            return localVarFp.createEventDef(eventDef, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete specific event def
         * @summary Deletes event def
         * @param {string} eventDefId The id of the event def to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEventDefById(eventDefId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteEventDefById(eventDefId, options).then((request) => request(axios, basePath));
        },
        /**
         * Info for specific event
         * @summary Gets detailed event
         * @param {number} eventId The id of the event to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventById(eventId: number, options?: RawAxiosRequestConfig): AxiosPromise<Event> {
            return localVarFp.getEventById(eventId, options).then((request) => request(axios, basePath));
        },
        /**
         * Info for specific event def
         * @summary Gets event def details
         * @param {string} eventDefId The id of the event def to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventDefById(eventDefId: string, options?: RawAxiosRequestConfig): AxiosPromise<EventDef> {
            return localVarFp.getEventDefById(eventDefId, options).then((request) => request(axios, basePath));
        },
        /**
         * List all event defs
         * @summary List event defs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listEventDefs(options?: RawAxiosRequestConfig): AxiosPromise<Array<EventDef>> {
            return localVarFp.listEventDefs(options).then((request) => request(axios, basePath));
        },
        /**
         * List all events
         * @summary List events
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listEvents(options?: RawAxiosRequestConfig): AxiosPromise<Array<Event>> {
            return localVarFp.listEvents(options).then((request) => request(axios, basePath));
        },
        /**
         * Update event def
         * @summary Updates event def
         * @param {string} eventDefId The id of the event def to retrieve
         * @param {EventDef} [eventDef] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEventDef(eventDefId: string, eventDef?: EventDef, options?: RawAxiosRequestConfig): AxiosPromise<EventDef> {
            return localVarFp.updateEventDef(eventDefId, eventDef, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * EventsApi - object-oriented interface
 * @export
 * @class EventsApi
 * @extends {BaseAPI}
 */
export class EventsApi extends BaseAPI {
    /**
     * Acknowledges an event
     * @summary Acknowledges ack
     * @param {number} eventId The id of the event to retrieve
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    public ackEvent(eventId: number, options?: RawAxiosRequestConfig) {
        return EventsApiFp(this.configuration).ackEvent(eventId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create an event def
     * @summary Create event def
     * @param {EventDef} [eventDef] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    public createEventDef(eventDef?: EventDef, options?: RawAxiosRequestConfig) {
        return EventsApiFp(this.configuration).createEventDef(eventDef, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete specific event def
     * @summary Deletes event def
     * @param {string} eventDefId The id of the event def to retrieve
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    public deleteEventDefById(eventDefId: string, options?: RawAxiosRequestConfig) {
        return EventsApiFp(this.configuration).deleteEventDefById(eventDefId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Info for specific event
     * @summary Gets detailed event
     * @param {number} eventId The id of the event to retrieve
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    public getEventById(eventId: number, options?: RawAxiosRequestConfig) {
        return EventsApiFp(this.configuration).getEventById(eventId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Info for specific event def
     * @summary Gets event def details
     * @param {string} eventDefId The id of the event def to retrieve
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    public getEventDefById(eventDefId: string, options?: RawAxiosRequestConfig) {
        return EventsApiFp(this.configuration).getEventDefById(eventDefId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List all event defs
     * @summary List event defs
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    public listEventDefs(options?: RawAxiosRequestConfig) {
        return EventsApiFp(this.configuration).listEventDefs(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List all events
     * @summary List events
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    public listEvents(options?: RawAxiosRequestConfig) {
        return EventsApiFp(this.configuration).listEvents(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update event def
     * @summary Updates event def
     * @param {string} eventDefId The id of the event def to retrieve
     * @param {EventDef} [eventDef] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    public updateEventDef(eventDefId: string, eventDef?: EventDef, options?: RawAxiosRequestConfig) {
        return EventsApiFp(this.configuration).updateEventDef(eventDefId, eventDef, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * MethodsApi - axios parameter creator
 * @export
 */
export const MethodsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Creates a  method
         * @summary Creates method
         * @param {number} pipelineId The id of the pipeline to retrieve
         * @param {Method} [method] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMethod: async (pipelineId: number, method?: Method, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pipelineId' is not null or undefined
            assertParamExists('createMethod', 'pipelineId', pipelineId)
            const localVarPath = `/pipeline/{pipelineId}/method`
                .replace(`{${"pipelineId"}}`, encodeURIComponent(String(pipelineId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(method, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes specific  method
         * @summary Deletes  method
         * @param {number} pipelineId The id of the pipeline to retrieve
         * @param {number} methodId The id of the pipeline method to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteMethodById: async (pipelineId: number, methodId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pipelineId' is not null or undefined
            assertParamExists('deleteMethodById', 'pipelineId', pipelineId)
            // verify required parameter 'methodId' is not null or undefined
            assertParamExists('deleteMethodById', 'methodId', methodId)
            const localVarPath = `/pipeline/{pipelineId}/method/{methodId}`
                .replace(`{${"pipelineId"}}`, encodeURIComponent(String(pipelineId)))
                .replace(`{${"methodId"}}`, encodeURIComponent(String(methodId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Info for specific  method
         * @summary Gets  method details
         * @param {number} pipelineId The id of the pipeline to retrieve
         * @param {number} methodId The id of the pipeline method to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMethodById: async (pipelineId: number, methodId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pipelineId' is not null or undefined
            assertParamExists('getMethodById', 'pipelineId', pipelineId)
            // verify required parameter 'methodId' is not null or undefined
            assertParamExists('getMethodById', 'methodId', methodId)
            const localVarPath = `/pipeline/{pipelineId}/method/{methodId}`
                .replace(`{${"pipelineId"}}`, encodeURIComponent(String(pipelineId)))
                .replace(`{${"methodId"}}`, encodeURIComponent(String(methodId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all  method params
         * @summary List pipelnie method params
         * @param {number} pipelineId The id of the pipeline to retrieve
         * @param {number} methodId The id of the pipeline method to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listMethodParams: async (pipelineId: number, methodId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pipelineId' is not null or undefined
            assertParamExists('listMethodParams', 'pipelineId', pipelineId)
            // verify required parameter 'methodId' is not null or undefined
            assertParamExists('listMethodParams', 'methodId', methodId)
            const localVarPath = `/pipeline/{pipelineId}/method/{methodId}/param`
                .replace(`{${"pipelineId"}}`, encodeURIComponent(String(pipelineId)))
                .replace(`{${"methodId"}}`, encodeURIComponent(String(methodId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all methods
         * @summary List pipelnie methods
         * @param {number} pipelineId The id of the pipeline to retrieve
         * @param {string} [$filter] Query filter in OData standard
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listMethods: async (pipelineId: number, $filter?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pipelineId' is not null or undefined
            assertParamExists('listMethods', 'pipelineId', pipelineId)
            const localVarPath = `/pipeline/{pipelineId}/method`
                .replace(`{${"pipelineId"}}`, encodeURIComponent(String(pipelineId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if ($filter !== undefined) {
                localVarQueryParameter['$filter'] = $filter;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates  method
         * @summary Updates method
         * @param {number} pipelineId The id of the pipeline to retrieve
         * @param {number} methodId The id of the pipeline method to retrieve
         * @param {Method} [method] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateMethod: async (pipelineId: number, methodId: number, method?: Method, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pipelineId' is not null or undefined
            assertParamExists('updateMethod', 'pipelineId', pipelineId)
            // verify required parameter 'methodId' is not null or undefined
            assertParamExists('updateMethod', 'methodId', methodId)
            const localVarPath = `/pipeline/{pipelineId}/method/{methodId}`
                .replace(`{${"pipelineId"}}`, encodeURIComponent(String(pipelineId)))
                .replace(`{${"methodId"}}`, encodeURIComponent(String(methodId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(method, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Put  method params
         * @summary Put pipelnie method params
         * @param {number} pipelineId The id of the pipeline to retrieve
         * @param {number} methodId The id of the pipeline method to retrieve
         * @param {string} methodParamDefId The id of the param to retrieve
         * @param {Array<MethodParam>} [methodParam] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateMethodParam: async (pipelineId: number, methodId: number, methodParamDefId: string, methodParam?: Array<MethodParam>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pipelineId' is not null or undefined
            assertParamExists('updateMethodParam', 'pipelineId', pipelineId)
            // verify required parameter 'methodId' is not null or undefined
            assertParamExists('updateMethodParam', 'methodId', methodId)
            // verify required parameter 'methodParamDefId' is not null or undefined
            assertParamExists('updateMethodParam', 'methodParamDefId', methodParamDefId)
            const localVarPath = `/pipeline/{pipelineId}/method/{methodId}/param/{methodParamDefId}`
                .replace(`{${"pipelineId"}}`, encodeURIComponent(String(pipelineId)))
                .replace(`{${"methodId"}}`, encodeURIComponent(String(methodId)))
                .replace(`{${"methodParamDefId"}}`, encodeURIComponent(String(methodParamDefId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(methodParam, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MethodsApi - functional programming interface
 * @export
 */
export const MethodsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MethodsApiAxiosParamCreator(configuration)
    return {
        /**
         * Creates a  method
         * @summary Creates method
         * @param {number} pipelineId The id of the pipeline to retrieve
         * @param {Method} [method] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createMethod(pipelineId: number, method?: Method, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Method>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createMethod(pipelineId, method, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MethodsApi.createMethod']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Deletes specific  method
         * @summary Deletes  method
         * @param {number} pipelineId The id of the pipeline to retrieve
         * @param {number} methodId The id of the pipeline method to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteMethodById(pipelineId: number, methodId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteMethodById(pipelineId, methodId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MethodsApi.deleteMethodById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Info for specific  method
         * @summary Gets  method details
         * @param {number} pipelineId The id of the pipeline to retrieve
         * @param {number} methodId The id of the pipeline method to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMethodById(pipelineId: number, methodId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Method>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMethodById(pipelineId, methodId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MethodsApi.getMethodById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List all  method params
         * @summary List pipelnie method params
         * @param {number} pipelineId The id of the pipeline to retrieve
         * @param {number} methodId The id of the pipeline method to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listMethodParams(pipelineId: number, methodId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<MethodParam>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listMethodParams(pipelineId, methodId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MethodsApi.listMethodParams']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List all methods
         * @summary List pipelnie methods
         * @param {number} pipelineId The id of the pipeline to retrieve
         * @param {string} [$filter] Query filter in OData standard
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listMethods(pipelineId: number, $filter?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Method>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listMethods(pipelineId, $filter, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MethodsApi.listMethods']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Updates  method
         * @summary Updates method
         * @param {number} pipelineId The id of the pipeline to retrieve
         * @param {number} methodId The id of the pipeline method to retrieve
         * @param {Method} [method] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateMethod(pipelineId: number, methodId: number, method?: Method, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Method>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateMethod(pipelineId, methodId, method, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MethodsApi.updateMethod']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Put  method params
         * @summary Put pipelnie method params
         * @param {number} pipelineId The id of the pipeline to retrieve
         * @param {number} methodId The id of the pipeline method to retrieve
         * @param {string} methodParamDefId The id of the param to retrieve
         * @param {Array<MethodParam>} [methodParam] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateMethodParam(pipelineId: number, methodId: number, methodParamDefId: string, methodParam?: Array<MethodParam>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Information>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateMethodParam(pipelineId, methodId, methodParamDefId, methodParam, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MethodsApi.updateMethodParam']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * MethodsApi - factory interface
 * @export
 */
export const MethodsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MethodsApiFp(configuration)
    return {
        /**
         * Creates a  method
         * @summary Creates method
         * @param {number} pipelineId The id of the pipeline to retrieve
         * @param {Method} [method] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMethod(pipelineId: number, method?: Method, options?: RawAxiosRequestConfig): AxiosPromise<Method> {
            return localVarFp.createMethod(pipelineId, method, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes specific  method
         * @summary Deletes  method
         * @param {number} pipelineId The id of the pipeline to retrieve
         * @param {number} methodId The id of the pipeline method to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteMethodById(pipelineId: number, methodId: number, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteMethodById(pipelineId, methodId, options).then((request) => request(axios, basePath));
        },
        /**
         * Info for specific  method
         * @summary Gets  method details
         * @param {number} pipelineId The id of the pipeline to retrieve
         * @param {number} methodId The id of the pipeline method to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMethodById(pipelineId: number, methodId: number, options?: RawAxiosRequestConfig): AxiosPromise<Method> {
            return localVarFp.getMethodById(pipelineId, methodId, options).then((request) => request(axios, basePath));
        },
        /**
         * List all  method params
         * @summary List pipelnie method params
         * @param {number} pipelineId The id of the pipeline to retrieve
         * @param {number} methodId The id of the pipeline method to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listMethodParams(pipelineId: number, methodId: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<MethodParam>> {
            return localVarFp.listMethodParams(pipelineId, methodId, options).then((request) => request(axios, basePath));
        },
        /**
         * List all methods
         * @summary List pipelnie methods
         * @param {number} pipelineId The id of the pipeline to retrieve
         * @param {string} [$filter] Query filter in OData standard
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listMethods(pipelineId: number, $filter?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<Method>> {
            return localVarFp.listMethods(pipelineId, $filter, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates  method
         * @summary Updates method
         * @param {number} pipelineId The id of the pipeline to retrieve
         * @param {number} methodId The id of the pipeline method to retrieve
         * @param {Method} [method] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateMethod(pipelineId: number, methodId: number, method?: Method, options?: RawAxiosRequestConfig): AxiosPromise<Method> {
            return localVarFp.updateMethod(pipelineId, methodId, method, options).then((request) => request(axios, basePath));
        },
        /**
         * Put  method params
         * @summary Put pipelnie method params
         * @param {number} pipelineId The id of the pipeline to retrieve
         * @param {number} methodId The id of the pipeline method to retrieve
         * @param {string} methodParamDefId The id of the param to retrieve
         * @param {Array<MethodParam>} [methodParam] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateMethodParam(pipelineId: number, methodId: number, methodParamDefId: string, methodParam?: Array<MethodParam>, options?: RawAxiosRequestConfig): AxiosPromise<Information> {
            return localVarFp.updateMethodParam(pipelineId, methodId, methodParamDefId, methodParam, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MethodsApi - object-oriented interface
 * @export
 * @class MethodsApi
 * @extends {BaseAPI}
 */
export class MethodsApi extends BaseAPI {
    /**
     * Creates a  method
     * @summary Creates method
     * @param {number} pipelineId The id of the pipeline to retrieve
     * @param {Method} [method] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MethodsApi
     */
    public createMethod(pipelineId: number, method?: Method, options?: RawAxiosRequestConfig) {
        return MethodsApiFp(this.configuration).createMethod(pipelineId, method, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes specific  method
     * @summary Deletes  method
     * @param {number} pipelineId The id of the pipeline to retrieve
     * @param {number} methodId The id of the pipeline method to retrieve
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MethodsApi
     */
    public deleteMethodById(pipelineId: number, methodId: number, options?: RawAxiosRequestConfig) {
        return MethodsApiFp(this.configuration).deleteMethodById(pipelineId, methodId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Info for specific  method
     * @summary Gets  method details
     * @param {number} pipelineId The id of the pipeline to retrieve
     * @param {number} methodId The id of the pipeline method to retrieve
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MethodsApi
     */
    public getMethodById(pipelineId: number, methodId: number, options?: RawAxiosRequestConfig) {
        return MethodsApiFp(this.configuration).getMethodById(pipelineId, methodId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List all  method params
     * @summary List pipelnie method params
     * @param {number} pipelineId The id of the pipeline to retrieve
     * @param {number} methodId The id of the pipeline method to retrieve
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MethodsApi
     */
    public listMethodParams(pipelineId: number, methodId: number, options?: RawAxiosRequestConfig) {
        return MethodsApiFp(this.configuration).listMethodParams(pipelineId, methodId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List all methods
     * @summary List pipelnie methods
     * @param {number} pipelineId The id of the pipeline to retrieve
     * @param {string} [$filter] Query filter in OData standard
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MethodsApi
     */
    public listMethods(pipelineId: number, $filter?: string, options?: RawAxiosRequestConfig) {
        return MethodsApiFp(this.configuration).listMethods(pipelineId, $filter, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates  method
     * @summary Updates method
     * @param {number} pipelineId The id of the pipeline to retrieve
     * @param {number} methodId The id of the pipeline method to retrieve
     * @param {Method} [method] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MethodsApi
     */
    public updateMethod(pipelineId: number, methodId: number, method?: Method, options?: RawAxiosRequestConfig) {
        return MethodsApiFp(this.configuration).updateMethod(pipelineId, methodId, method, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Put  method params
     * @summary Put pipelnie method params
     * @param {number} pipelineId The id of the pipeline to retrieve
     * @param {number} methodId The id of the pipeline method to retrieve
     * @param {string} methodParamDefId The id of the param to retrieve
     * @param {Array<MethodParam>} [methodParam] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MethodsApi
     */
    public updateMethodParam(pipelineId: number, methodId: number, methodParamDefId: string, methodParam?: Array<MethodParam>, options?: RawAxiosRequestConfig) {
        return MethodsApiFp(this.configuration).updateMethodParam(pipelineId, methodId, methodParamDefId, methodParam, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * NodesApi - axios parameter creator
 * @export
 */
export const NodesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a nodes
         * @summary Create nodes
         * @param {Node} [node] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createNode: async (node?: Node, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/node`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(node, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes specific node
         * @summary Deletes node
         * @param {number} nodeId The id of the node to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteNodeById: async (nodeId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'nodeId' is not null or undefined
            assertParamExists('deleteNodeById', 'nodeId', nodeId)
            const localVarPath = `/node/{nodeId}`
                .replace(`{${"nodeId"}}`, encodeURIComponent(String(nodeId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Info for specific node
         * @summary Gets node details
         * @param {number} nodeId The id of the node to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNodeById: async (nodeId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'nodeId' is not null or undefined
            assertParamExists('getNodeById', 'nodeId', nodeId)
            const localVarPath = `/node/{nodeId}`
                .replace(`{${"nodeId"}}`, encodeURIComponent(String(nodeId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all nodes
         * @summary List nodes
         * @param {string} [$filter] Query filter in OData standard
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listNodes: async ($filter?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/node`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if ($filter !== undefined) {
                localVarQueryParameter['$filter'] = $filter;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates a nodes
         * @summary Updates nodes
         * @param {number} nodeId The id of the node to retrieve
         * @param {Node} [node] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateNode: async (nodeId: number, node?: Node, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'nodeId' is not null or undefined
            assertParamExists('updateNode', 'nodeId', nodeId)
            const localVarPath = `/node/{nodeId}`
                .replace(`{${"nodeId"}}`, encodeURIComponent(String(nodeId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(node, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * NodesApi - functional programming interface
 * @export
 */
export const NodesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = NodesApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a nodes
         * @summary Create nodes
         * @param {Node} [node] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createNode(node?: Node, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Node>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createNode(node, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['NodesApi.createNode']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Deletes specific node
         * @summary Deletes node
         * @param {number} nodeId The id of the node to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteNodeById(nodeId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteNodeById(nodeId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['NodesApi.deleteNodeById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Info for specific node
         * @summary Gets node details
         * @param {number} nodeId The id of the node to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getNodeById(nodeId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Node>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getNodeById(nodeId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['NodesApi.getNodeById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List all nodes
         * @summary List nodes
         * @param {string} [$filter] Query filter in OData standard
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listNodes($filter?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Node>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listNodes($filter, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['NodesApi.listNodes']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Updates a nodes
         * @summary Updates nodes
         * @param {number} nodeId The id of the node to retrieve
         * @param {Node} [node] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateNode(nodeId: number, node?: Node, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Node>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateNode(nodeId, node, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['NodesApi.updateNode']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * NodesApi - factory interface
 * @export
 */
export const NodesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = NodesApiFp(configuration)
    return {
        /**
         * Create a nodes
         * @summary Create nodes
         * @param {Node} [node] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createNode(node?: Node, options?: RawAxiosRequestConfig): AxiosPromise<Node> {
            return localVarFp.createNode(node, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes specific node
         * @summary Deletes node
         * @param {number} nodeId The id of the node to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteNodeById(nodeId: number, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteNodeById(nodeId, options).then((request) => request(axios, basePath));
        },
        /**
         * Info for specific node
         * @summary Gets node details
         * @param {number} nodeId The id of the node to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNodeById(nodeId: number, options?: RawAxiosRequestConfig): AxiosPromise<Node> {
            return localVarFp.getNodeById(nodeId, options).then((request) => request(axios, basePath));
        },
        /**
         * List all nodes
         * @summary List nodes
         * @param {string} [$filter] Query filter in OData standard
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listNodes($filter?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<Node>> {
            return localVarFp.listNodes($filter, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates a nodes
         * @summary Updates nodes
         * @param {number} nodeId The id of the node to retrieve
         * @param {Node} [node] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateNode(nodeId: number, node?: Node, options?: RawAxiosRequestConfig): AxiosPromise<Node> {
            return localVarFp.updateNode(nodeId, node, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * NodesApi - object-oriented interface
 * @export
 * @class NodesApi
 * @extends {BaseAPI}
 */
export class NodesApi extends BaseAPI {
    /**
     * Create a nodes
     * @summary Create nodes
     * @param {Node} [node] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NodesApi
     */
    public createNode(node?: Node, options?: RawAxiosRequestConfig) {
        return NodesApiFp(this.configuration).createNode(node, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes specific node
     * @summary Deletes node
     * @param {number} nodeId The id of the node to retrieve
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NodesApi
     */
    public deleteNodeById(nodeId: number, options?: RawAxiosRequestConfig) {
        return NodesApiFp(this.configuration).deleteNodeById(nodeId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Info for specific node
     * @summary Gets node details
     * @param {number} nodeId The id of the node to retrieve
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NodesApi
     */
    public getNodeById(nodeId: number, options?: RawAxiosRequestConfig) {
        return NodesApiFp(this.configuration).getNodeById(nodeId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List all nodes
     * @summary List nodes
     * @param {string} [$filter] Query filter in OData standard
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NodesApi
     */
    public listNodes($filter?: string, options?: RawAxiosRequestConfig) {
        return NodesApiFp(this.configuration).listNodes($filter, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates a nodes
     * @summary Updates nodes
     * @param {number} nodeId The id of the node to retrieve
     * @param {Node} [node] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NodesApi
     */
    public updateNode(nodeId: number, node?: Node, options?: RawAxiosRequestConfig) {
        return NodesApiFp(this.configuration).updateNode(nodeId, node, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * PipelinesApi - axios parameter creator
 * @export
 */
export const PipelinesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a pipeline
         * @summary Create pipeline
         * @param {Pipeline} [pipeline] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPipeline: async (pipeline?: Pipeline, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/pipeline`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(pipeline, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes specific pipeline
         * @summary Deletes pipeline
         * @param {number} pipelineId The id of the pipeline to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePipelineById: async (pipelineId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pipelineId' is not null or undefined
            assertParamExists('deletePipelineById', 'pipelineId', pipelineId)
            const localVarPath = `/pipeline/{pipelineId}`
                .replace(`{${"pipelineId"}}`, encodeURIComponent(String(pipelineId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Info for specific pipeline
         * @summary Gets pipeline details
         * @param {number} pipelineId The id of the pipeline to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPipelineById: async (pipelineId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pipelineId' is not null or undefined
            assertParamExists('getPipelineById', 'pipelineId', pipelineId)
            const localVarPath = `/pipeline/{pipelineId}`
                .replace(`{${"pipelineId"}}`, encodeURIComponent(String(pipelineId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all  pipeline params
         * @summary List pipelnie pipeline params
         * @param {number} pipelineId The id of the pipeline to retrieve
         * @param {string} [$filter] Query filter in OData standard
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPipelineParams: async (pipelineId: number, $filter?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pipelineId' is not null or undefined
            assertParamExists('listPipelineParams', 'pipelineId', pipelineId)
            const localVarPath = `/pipeline/{pipelineId}/param`
                .replace(`{${"pipelineId"}}`, encodeURIComponent(String(pipelineId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if ($filter !== undefined) {
                localVarQueryParameter['$filter'] = $filter;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all pipelines
         * @summary List pipelines
         * @param {string} [$filter] Query filter in OData standard
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPipelines: async ($filter?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/pipeline`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if ($filter !== undefined) {
                localVarQueryParameter['$filter'] = $filter;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates pipeline
         * @summary Updates pipeline
         * @param {number} pipelineId The id of the pipeline to retrieve
         * @param {Pipeline} [pipeline] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePipeline: async (pipelineId: number, pipeline?: Pipeline, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pipelineId' is not null or undefined
            assertParamExists('updatePipeline', 'pipelineId', pipelineId)
            const localVarPath = `/pipeline/{pipelineId}`
                .replace(`{${"pipelineId"}}`, encodeURIComponent(String(pipelineId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(pipeline, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Put  pipeline params
         * @summary Put pipelnie pipeline params
         * @param {number} pipelineId The id of the pipeline to retrieve
         * @param {string} pipelineParamDefId The id of the param to retrieve
         * @param {Array<PipelineParam>} [pipelineParam] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePipelineParam: async (pipelineId: number, pipelineParamDefId: string, pipelineParam?: Array<PipelineParam>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pipelineId' is not null or undefined
            assertParamExists('updatePipelineParam', 'pipelineId', pipelineId)
            // verify required parameter 'pipelineParamDefId' is not null or undefined
            assertParamExists('updatePipelineParam', 'pipelineParamDefId', pipelineParamDefId)
            const localVarPath = `/pipeline/{pipelineId}/param/{pipelineParamDefId}`
                .replace(`{${"pipelineId"}}`, encodeURIComponent(String(pipelineId)))
                .replace(`{${"pipelineParamDefId"}}`, encodeURIComponent(String(pipelineParamDefId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(pipelineParam, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PipelinesApi - functional programming interface
 * @export
 */
export const PipelinesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PipelinesApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a pipeline
         * @summary Create pipeline
         * @param {Pipeline} [pipeline] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createPipeline(pipeline?: Pipeline, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Pipeline>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createPipeline(pipeline, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PipelinesApi.createPipeline']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Deletes specific pipeline
         * @summary Deletes pipeline
         * @param {number} pipelineId The id of the pipeline to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deletePipelineById(pipelineId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deletePipelineById(pipelineId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PipelinesApi.deletePipelineById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Info for specific pipeline
         * @summary Gets pipeline details
         * @param {number} pipelineId The id of the pipeline to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPipelineById(pipelineId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Pipeline>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPipelineById(pipelineId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PipelinesApi.getPipelineById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List all  pipeline params
         * @summary List pipelnie pipeline params
         * @param {number} pipelineId The id of the pipeline to retrieve
         * @param {string} [$filter] Query filter in OData standard
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listPipelineParams(pipelineId: number, $filter?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PipelineParam>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listPipelineParams(pipelineId, $filter, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PipelinesApi.listPipelineParams']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List all pipelines
         * @summary List pipelines
         * @param {string} [$filter] Query filter in OData standard
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listPipelines($filter?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Pipeline>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listPipelines($filter, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PipelinesApi.listPipelines']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Updates pipeline
         * @summary Updates pipeline
         * @param {number} pipelineId The id of the pipeline to retrieve
         * @param {Pipeline} [pipeline] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updatePipeline(pipelineId: number, pipeline?: Pipeline, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Pipeline>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updatePipeline(pipelineId, pipeline, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PipelinesApi.updatePipeline']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Put  pipeline params
         * @summary Put pipelnie pipeline params
         * @param {number} pipelineId The id of the pipeline to retrieve
         * @param {string} pipelineParamDefId The id of the param to retrieve
         * @param {Array<PipelineParam>} [pipelineParam] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updatePipelineParam(pipelineId: number, pipelineParamDefId: string, pipelineParam?: Array<PipelineParam>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Information>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updatePipelineParam(pipelineId, pipelineParamDefId, pipelineParam, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PipelinesApi.updatePipelineParam']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * PipelinesApi - factory interface
 * @export
 */
export const PipelinesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PipelinesApiFp(configuration)
    return {
        /**
         * Create a pipeline
         * @summary Create pipeline
         * @param {Pipeline} [pipeline] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPipeline(pipeline?: Pipeline, options?: RawAxiosRequestConfig): AxiosPromise<Pipeline> {
            return localVarFp.createPipeline(pipeline, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes specific pipeline
         * @summary Deletes pipeline
         * @param {number} pipelineId The id of the pipeline to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePipelineById(pipelineId: number, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deletePipelineById(pipelineId, options).then((request) => request(axios, basePath));
        },
        /**
         * Info for specific pipeline
         * @summary Gets pipeline details
         * @param {number} pipelineId The id of the pipeline to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPipelineById(pipelineId: number, options?: RawAxiosRequestConfig): AxiosPromise<Pipeline> {
            return localVarFp.getPipelineById(pipelineId, options).then((request) => request(axios, basePath));
        },
        /**
         * List all  pipeline params
         * @summary List pipelnie pipeline params
         * @param {number} pipelineId The id of the pipeline to retrieve
         * @param {string} [$filter] Query filter in OData standard
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPipelineParams(pipelineId: number, $filter?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<PipelineParam>> {
            return localVarFp.listPipelineParams(pipelineId, $filter, options).then((request) => request(axios, basePath));
        },
        /**
         * List all pipelines
         * @summary List pipelines
         * @param {string} [$filter] Query filter in OData standard
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPipelines($filter?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<Pipeline>> {
            return localVarFp.listPipelines($filter, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates pipeline
         * @summary Updates pipeline
         * @param {number} pipelineId The id of the pipeline to retrieve
         * @param {Pipeline} [pipeline] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePipeline(pipelineId: number, pipeline?: Pipeline, options?: RawAxiosRequestConfig): AxiosPromise<Pipeline> {
            return localVarFp.updatePipeline(pipelineId, pipeline, options).then((request) => request(axios, basePath));
        },
        /**
         * Put  pipeline params
         * @summary Put pipelnie pipeline params
         * @param {number} pipelineId The id of the pipeline to retrieve
         * @param {string} pipelineParamDefId The id of the param to retrieve
         * @param {Array<PipelineParam>} [pipelineParam] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePipelineParam(pipelineId: number, pipelineParamDefId: string, pipelineParam?: Array<PipelineParam>, options?: RawAxiosRequestConfig): AxiosPromise<Information> {
            return localVarFp.updatePipelineParam(pipelineId, pipelineParamDefId, pipelineParam, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PipelinesApi - object-oriented interface
 * @export
 * @class PipelinesApi
 * @extends {BaseAPI}
 */
export class PipelinesApi extends BaseAPI {
    /**
     * Create a pipeline
     * @summary Create pipeline
     * @param {Pipeline} [pipeline] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PipelinesApi
     */
    public createPipeline(pipeline?: Pipeline, options?: RawAxiosRequestConfig) {
        return PipelinesApiFp(this.configuration).createPipeline(pipeline, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes specific pipeline
     * @summary Deletes pipeline
     * @param {number} pipelineId The id of the pipeline to retrieve
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PipelinesApi
     */
    public deletePipelineById(pipelineId: number, options?: RawAxiosRequestConfig) {
        return PipelinesApiFp(this.configuration).deletePipelineById(pipelineId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Info for specific pipeline
     * @summary Gets pipeline details
     * @param {number} pipelineId The id of the pipeline to retrieve
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PipelinesApi
     */
    public getPipelineById(pipelineId: number, options?: RawAxiosRequestConfig) {
        return PipelinesApiFp(this.configuration).getPipelineById(pipelineId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List all  pipeline params
     * @summary List pipelnie pipeline params
     * @param {number} pipelineId The id of the pipeline to retrieve
     * @param {string} [$filter] Query filter in OData standard
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PipelinesApi
     */
    public listPipelineParams(pipelineId: number, $filter?: string, options?: RawAxiosRequestConfig) {
        return PipelinesApiFp(this.configuration).listPipelineParams(pipelineId, $filter, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List all pipelines
     * @summary List pipelines
     * @param {string} [$filter] Query filter in OData standard
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PipelinesApi
     */
    public listPipelines($filter?: string, options?: RawAxiosRequestConfig) {
        return PipelinesApiFp(this.configuration).listPipelines($filter, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates pipeline
     * @summary Updates pipeline
     * @param {number} pipelineId The id of the pipeline to retrieve
     * @param {Pipeline} [pipeline] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PipelinesApi
     */
    public updatePipeline(pipelineId: number, pipeline?: Pipeline, options?: RawAxiosRequestConfig) {
        return PipelinesApiFp(this.configuration).updatePipeline(pipelineId, pipeline, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Put  pipeline params
     * @summary Put pipelnie pipeline params
     * @param {number} pipelineId The id of the pipeline to retrieve
     * @param {string} pipelineParamDefId The id of the param to retrieve
     * @param {Array<PipelineParam>} [pipelineParam] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PipelinesApi
     */
    public updatePipelineParam(pipelineId: number, pipelineParamDefId: string, pipelineParam?: Array<PipelineParam>, options?: RawAxiosRequestConfig) {
        return PipelinesApiFp(this.configuration).updatePipelineParam(pipelineId, pipelineParamDefId, pipelineParam, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * TrendsApi - axios parameter creator
 * @export
 */
export const TrendsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a trend
         * @summary Create trend
         * @param {Trend} [trend] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTrend: async (trend?: Trend, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/trend`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(trend, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes specific trend
         * @summary Deletes trend
         * @param {number} trendId The id of the trend to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTrendById: async (trendId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'trendId' is not null or undefined
            assertParamExists('deleteTrendById', 'trendId', trendId)
            const localVarPath = `/trend/{trendId}`
                .replace(`{${"trendId"}}`, encodeURIComponent(String(trendId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Info for specific trend
         * @summary Detail trend
         * @param {number} trendId The id of the trend to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTrendById: async (trendId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'trendId' is not null or undefined
            assertParamExists('getTrendById', 'trendId', trendId)
            const localVarPath = `/trend/{trendId}`
                .replace(`{${"trendId"}}`, encodeURIComponent(String(trendId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List trend current data
         * @summary List trend current data
         * @param {string} trendIdList String of ids of the trend to retrieve, separated by comma
         * @param {number} period period of data to take since current time (timestamp UTC)
         * @param {number} samples number of data samples to take (resolution)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTrendCurrentData: async (trendIdList: string, period: number, samples: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'trendIdList' is not null or undefined
            assertParamExists('getTrendCurrentData', 'trendIdList', trendIdList)
            // verify required parameter 'period' is not null or undefined
            assertParamExists('getTrendCurrentData', 'period', period)
            // verify required parameter 'samples' is not null or undefined
            assertParamExists('getTrendCurrentData', 'samples', samples)
            const localVarPath = `/trend/{trendIdList}/current_data/{period}/{samples}`
                .replace(`{${"trendIdList"}}`, encodeURIComponent(String(trendIdList)))
                .replace(`{${"period"}}`, encodeURIComponent(String(period)))
                .replace(`{${"samples"}}`, encodeURIComponent(String(samples)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List data
         * @summary List trend data
         * @param {string} trendIdList String of ids of the trend to retrieve, separated by comma
         * @param {number} begin start of date to take from data (timestamp UTC)
         * @param {number} end end of date to take from data (timestamp UTC)
         * @param {number} samples number of data samples to take (resolution)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTrendData: async (trendIdList: string, begin: number, end: number, samples: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'trendIdList' is not null or undefined
            assertParamExists('getTrendData', 'trendIdList', trendIdList)
            // verify required parameter 'begin' is not null or undefined
            assertParamExists('getTrendData', 'begin', begin)
            // verify required parameter 'end' is not null or undefined
            assertParamExists('getTrendData', 'end', end)
            // verify required parameter 'samples' is not null or undefined
            assertParamExists('getTrendData', 'samples', samples)
            const localVarPath = `/trend/{trendIdList}/data/{begin}/{end}/{samples}`
                .replace(`{${"trendIdList"}}`, encodeURIComponent(String(trendIdList)))
                .replace(`{${"begin"}}`, encodeURIComponent(String(begin)))
                .replace(`{${"end"}}`, encodeURIComponent(String(end)))
                .replace(`{${"samples"}}`, encodeURIComponent(String(samples)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Info for specific trend param
         * @summary Gets trend param detail
         * @param {number} trendId The id of the trend to retrieve
         * @param {string} trendParamDefId The id of the param to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTrendParamById: async (trendId: number, trendParamDefId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'trendId' is not null or undefined
            assertParamExists('getTrendParamById', 'trendId', trendId)
            // verify required parameter 'trendParamDefId' is not null or undefined
            assertParamExists('getTrendParamById', 'trendParamDefId', trendParamDefId)
            const localVarPath = `/trend/{trendId}/param/{trendParamDefId}`
                .replace(`{${"trendId"}}`, encodeURIComponent(String(trendId)))
                .replace(`{${"trendParamDefId"}}`, encodeURIComponent(String(trendParamDefId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all trend defs
         * @summary List trend defs
         * @param {string} [$filter] Query filter in OData standard
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTrendDefs: async ($filter?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/trend_def`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if ($filter !== undefined) {
                localVarQueryParameter['$filter'] = $filter;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all trend params
         * @summary List trend params
         * @param {number} trendId The id of the trend to retrieve
         * @param {string} [$filter] Query filter in OData standard
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTrendParams: async (trendId: number, $filter?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'trendId' is not null or undefined
            assertParamExists('listTrendParams', 'trendId', trendId)
            const localVarPath = `/trend/{trendId}/param`
                .replace(`{${"trendId"}}`, encodeURIComponent(String(trendId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if ($filter !== undefined) {
                localVarQueryParameter['$filter'] = $filter;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all trends
         * @summary List trends
         * @param {string} [$filter] Query filter in OData standard
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTrends: async ($filter?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/trend`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if ($filter !== undefined) {
                localVarQueryParameter['$filter'] = $filter;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a trend
         * @summary Update trend
         * @param {number} trendId The id of the trend to retrieve
         * @param {Trend} [trend] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTrend: async (trendId: number, trend?: Trend, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'trendId' is not null or undefined
            assertParamExists('updateTrend', 'trendId', trendId)
            const localVarPath = `/trend/{trendId}`
                .replace(`{${"trendId"}}`, encodeURIComponent(String(trendId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(trend, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates trend param
         * @summary Update trend params
         * @param {number} trendId The id of the trend to retrieve
         * @param {string} trendParamDefId The id of the param to retrieve
         * @param {string} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTrendParam: async (trendId: number, trendParamDefId: string, body?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'trendId' is not null or undefined
            assertParamExists('updateTrendParam', 'trendId', trendId)
            // verify required parameter 'trendParamDefId' is not null or undefined
            assertParamExists('updateTrendParam', 'trendParamDefId', trendParamDefId)
            const localVarPath = `/trend/{trendId}/param/{trendParamDefId}`
                .replace(`{${"trendId"}}`, encodeURIComponent(String(trendId)))
                .replace(`{${"trendParamDefId"}}`, encodeURIComponent(String(trendParamDefId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TrendsApi - functional programming interface
 * @export
 */
export const TrendsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TrendsApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a trend
         * @summary Create trend
         * @param {Trend} [trend] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createTrend(trend?: Trend, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Trend>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createTrend(trend, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TrendsApi.createTrend']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Deletes specific trend
         * @summary Deletes trend
         * @param {number} trendId The id of the trend to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteTrendById(trendId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteTrendById(trendId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TrendsApi.deleteTrendById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Info for specific trend
         * @summary Detail trend
         * @param {number} trendId The id of the trend to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTrendById(trendId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Trend>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTrendById(trendId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TrendsApi.getTrendById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List trend current data
         * @summary List trend current data
         * @param {string} trendIdList String of ids of the trend to retrieve, separated by comma
         * @param {number} period period of data to take since current time (timestamp UTC)
         * @param {number} samples number of data samples to take (resolution)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTrendCurrentData(trendIdList: string, period: number, samples: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TrendData>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTrendCurrentData(trendIdList, period, samples, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TrendsApi.getTrendCurrentData']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List data
         * @summary List trend data
         * @param {string} trendIdList String of ids of the trend to retrieve, separated by comma
         * @param {number} begin start of date to take from data (timestamp UTC)
         * @param {number} end end of date to take from data (timestamp UTC)
         * @param {number} samples number of data samples to take (resolution)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTrendData(trendIdList: string, begin: number, end: number, samples: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TrendData>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTrendData(trendIdList, begin, end, samples, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TrendsApi.getTrendData']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Info for specific trend param
         * @summary Gets trend param detail
         * @param {number} trendId The id of the trend to retrieve
         * @param {string} trendParamDefId The id of the param to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTrendParamById(trendId: number, trendParamDefId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TrendParam>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTrendParamById(trendId, trendParamDefId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TrendsApi.getTrendParamById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List all trend defs
         * @summary List trend defs
         * @param {string} [$filter] Query filter in OData standard
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listTrendDefs($filter?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TrendDef>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listTrendDefs($filter, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TrendsApi.listTrendDefs']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List all trend params
         * @summary List trend params
         * @param {number} trendId The id of the trend to retrieve
         * @param {string} [$filter] Query filter in OData standard
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listTrendParams(trendId: number, $filter?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TrendParam>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listTrendParams(trendId, $filter, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TrendsApi.listTrendParams']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List all trends
         * @summary List trends
         * @param {string} [$filter] Query filter in OData standard
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listTrends($filter?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Trend>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listTrends($filter, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TrendsApi.listTrends']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update a trend
         * @summary Update trend
         * @param {number} trendId The id of the trend to retrieve
         * @param {Trend} [trend] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateTrend(trendId: number, trend?: Trend, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Trend>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateTrend(trendId, trend, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TrendsApi.updateTrend']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Updates trend param
         * @summary Update trend params
         * @param {number} trendId The id of the trend to retrieve
         * @param {string} trendParamDefId The id of the param to retrieve
         * @param {string} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateTrendParam(trendId: number, trendParamDefId: string, body?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TrendParam>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateTrendParam(trendId, trendParamDefId, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TrendsApi.updateTrendParam']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * TrendsApi - factory interface
 * @export
 */
export const TrendsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TrendsApiFp(configuration)
    return {
        /**
         * Create a trend
         * @summary Create trend
         * @param {Trend} [trend] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTrend(trend?: Trend, options?: RawAxiosRequestConfig): AxiosPromise<Trend> {
            return localVarFp.createTrend(trend, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes specific trend
         * @summary Deletes trend
         * @param {number} trendId The id of the trend to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTrendById(trendId: number, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteTrendById(trendId, options).then((request) => request(axios, basePath));
        },
        /**
         * Info for specific trend
         * @summary Detail trend
         * @param {number} trendId The id of the trend to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTrendById(trendId: number, options?: RawAxiosRequestConfig): AxiosPromise<Trend> {
            return localVarFp.getTrendById(trendId, options).then((request) => request(axios, basePath));
        },
        /**
         * List trend current data
         * @summary List trend current data
         * @param {string} trendIdList String of ids of the trend to retrieve, separated by comma
         * @param {number} period period of data to take since current time (timestamp UTC)
         * @param {number} samples number of data samples to take (resolution)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTrendCurrentData(trendIdList: string, period: number, samples: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<TrendData>> {
            return localVarFp.getTrendCurrentData(trendIdList, period, samples, options).then((request) => request(axios, basePath));
        },
        /**
         * List data
         * @summary List trend data
         * @param {string} trendIdList String of ids of the trend to retrieve, separated by comma
         * @param {number} begin start of date to take from data (timestamp UTC)
         * @param {number} end end of date to take from data (timestamp UTC)
         * @param {number} samples number of data samples to take (resolution)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTrendData(trendIdList: string, begin: number, end: number, samples: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<TrendData>> {
            return localVarFp.getTrendData(trendIdList, begin, end, samples, options).then((request) => request(axios, basePath));
        },
        /**
         * Info for specific trend param
         * @summary Gets trend param detail
         * @param {number} trendId The id of the trend to retrieve
         * @param {string} trendParamDefId The id of the param to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTrendParamById(trendId: number, trendParamDefId: string, options?: RawAxiosRequestConfig): AxiosPromise<TrendParam> {
            return localVarFp.getTrendParamById(trendId, trendParamDefId, options).then((request) => request(axios, basePath));
        },
        /**
         * List all trend defs
         * @summary List trend defs
         * @param {string} [$filter] Query filter in OData standard
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTrendDefs($filter?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<TrendDef>> {
            return localVarFp.listTrendDefs($filter, options).then((request) => request(axios, basePath));
        },
        /**
         * List all trend params
         * @summary List trend params
         * @param {number} trendId The id of the trend to retrieve
         * @param {string} [$filter] Query filter in OData standard
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTrendParams(trendId: number, $filter?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<TrendParam>> {
            return localVarFp.listTrendParams(trendId, $filter, options).then((request) => request(axios, basePath));
        },
        /**
         * List all trends
         * @summary List trends
         * @param {string} [$filter] Query filter in OData standard
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTrends($filter?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<Trend>> {
            return localVarFp.listTrends($filter, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a trend
         * @summary Update trend
         * @param {number} trendId The id of the trend to retrieve
         * @param {Trend} [trend] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTrend(trendId: number, trend?: Trend, options?: RawAxiosRequestConfig): AxiosPromise<Trend> {
            return localVarFp.updateTrend(trendId, trend, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates trend param
         * @summary Update trend params
         * @param {number} trendId The id of the trend to retrieve
         * @param {string} trendParamDefId The id of the param to retrieve
         * @param {string} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTrendParam(trendId: number, trendParamDefId: string, body?: string, options?: RawAxiosRequestConfig): AxiosPromise<TrendParam> {
            return localVarFp.updateTrendParam(trendId, trendParamDefId, body, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TrendsApi - object-oriented interface
 * @export
 * @class TrendsApi
 * @extends {BaseAPI}
 */
export class TrendsApi extends BaseAPI {
    /**
     * Create a trend
     * @summary Create trend
     * @param {Trend} [trend] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TrendsApi
     */
    public createTrend(trend?: Trend, options?: RawAxiosRequestConfig) {
        return TrendsApiFp(this.configuration).createTrend(trend, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes specific trend
     * @summary Deletes trend
     * @param {number} trendId The id of the trend to retrieve
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TrendsApi
     */
    public deleteTrendById(trendId: number, options?: RawAxiosRequestConfig) {
        return TrendsApiFp(this.configuration).deleteTrendById(trendId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Info for specific trend
     * @summary Detail trend
     * @param {number} trendId The id of the trend to retrieve
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TrendsApi
     */
    public getTrendById(trendId: number, options?: RawAxiosRequestConfig) {
        return TrendsApiFp(this.configuration).getTrendById(trendId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List trend current data
     * @summary List trend current data
     * @param {string} trendIdList String of ids of the trend to retrieve, separated by comma
     * @param {number} period period of data to take since current time (timestamp UTC)
     * @param {number} samples number of data samples to take (resolution)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TrendsApi
     */
    public getTrendCurrentData(trendIdList: string, period: number, samples: number, options?: RawAxiosRequestConfig) {
        return TrendsApiFp(this.configuration).getTrendCurrentData(trendIdList, period, samples, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List data
     * @summary List trend data
     * @param {string} trendIdList String of ids of the trend to retrieve, separated by comma
     * @param {number} begin start of date to take from data (timestamp UTC)
     * @param {number} end end of date to take from data (timestamp UTC)
     * @param {number} samples number of data samples to take (resolution)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TrendsApi
     */
    public getTrendData(trendIdList: string, begin: number, end: number, samples: number, options?: RawAxiosRequestConfig) {
        return TrendsApiFp(this.configuration).getTrendData(trendIdList, begin, end, samples, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Info for specific trend param
     * @summary Gets trend param detail
     * @param {number} trendId The id of the trend to retrieve
     * @param {string} trendParamDefId The id of the param to retrieve
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TrendsApi
     */
    public getTrendParamById(trendId: number, trendParamDefId: string, options?: RawAxiosRequestConfig) {
        return TrendsApiFp(this.configuration).getTrendParamById(trendId, trendParamDefId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List all trend defs
     * @summary List trend defs
     * @param {string} [$filter] Query filter in OData standard
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TrendsApi
     */
    public listTrendDefs($filter?: string, options?: RawAxiosRequestConfig) {
        return TrendsApiFp(this.configuration).listTrendDefs($filter, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List all trend params
     * @summary List trend params
     * @param {number} trendId The id of the trend to retrieve
     * @param {string} [$filter] Query filter in OData standard
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TrendsApi
     */
    public listTrendParams(trendId: number, $filter?: string, options?: RawAxiosRequestConfig) {
        return TrendsApiFp(this.configuration).listTrendParams(trendId, $filter, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List all trends
     * @summary List trends
     * @param {string} [$filter] Query filter in OData standard
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TrendsApi
     */
    public listTrends($filter?: string, options?: RawAxiosRequestConfig) {
        return TrendsApiFp(this.configuration).listTrends($filter, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a trend
     * @summary Update trend
     * @param {number} trendId The id of the trend to retrieve
     * @param {Trend} [trend] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TrendsApi
     */
    public updateTrend(trendId: number, trend?: Trend, options?: RawAxiosRequestConfig) {
        return TrendsApiFp(this.configuration).updateTrend(trendId, trend, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates trend param
     * @summary Update trend params
     * @param {number} trendId The id of the trend to retrieve
     * @param {string} trendParamDefId The id of the param to retrieve
     * @param {string} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TrendsApi
     */
    public updateTrendParam(trendId: number, trendParamDefId: string, body?: string, options?: RawAxiosRequestConfig) {
        return TrendsApiFp(this.configuration).updateTrendParam(trendId, trendParamDefId, body, options).then((request) => request(this.axios, this.basePath));
    }
}



